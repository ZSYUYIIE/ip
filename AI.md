# Stream API Refactoring Summary

**Generated by:** Claude Haiku 4.5  
**Date:** February 19, 2026  
**Purpose:** Refactor Java code to use functional programming style with Stream API

## Overview
This document details all methods refactored to use Java Stream API and functional programming paradigms instead of traditional imperative loops.

---

## Refactored Files

### 1. **TaskList.java** - `find()` method
**Location:** [src/main/java/zwee/task/TaskList.java](src/main/java/zwee/task/TaskList.java#L61-L70)

**Original Code:**
```java
public TaskList find(String description) {
    List<Task> foundTasks = new ArrayList<>();
    for (Task task : tasks) {
        if (task.getDescription().contains(description)) {
            foundTasks.add(task);
        }
    }
    return new TaskList(foundTasks);
}
```

**Refactored Code:**
```java
public TaskList find(String description) {
    List<Task> foundTasks = tasks.stream()
            .filter(task -> task.getDescription().contains(description))
            .collect(Collectors.toList());
    return new TaskList(foundTasks);
}
```

**Benefits:**
- Cleaner, more declarative code
- Uses lambda expressions for filtering
- More concise and readable

**Stream API Operations Used:**
- `stream()` - Creates stream from list
- `filter()` - Filters tasks by description
- `collect()` - Collects results back into a list

---

### 2. **Storage.java** - `load()` method
**Location:** [src/main/java/zwee/storage/Storage.java](src/main/java/zwee/storage/Storage.java#L42-L58)

**Original Code:**
```java
public List<Task> load() {
    List<Task> tasks = new ArrayList<>();
    try (BufferedReader br = new BufferedReader(new FileReader(file))) {
        String line;
        while ((line = br.readLine()) != null) {
            if (!line.trim().isEmpty()) {
                tasks.add(Parser.parseStoredTask(line));
            }
        }
    } catch (IOException e) {
        throw new ZweeException("Error loading tasks.");
    }
    return tasks;
}
```

**Refactored Code:**
```java
public List<Task> load() {
    assert this.file != null : "File should not be null";
    try (BufferedReader br = new BufferedReader(new FileReader(file))) {
        List<Task> tasks = br.lines()
                .filter(line -> !line.trim().isEmpty())
                .map(Parser::parseStoredTask)
                .collect(Collectors.toList());
        return tasks;
    } catch (IOException e) {
        throw new ZweeException("Error loading tasks.");
    }
}
```

**Benefits:**
- Uses `BufferedReader.lines()` stream instead of while loop
- Simplified filtering logic with lambda expressions
- Method reference (`Parser::parseStoredTask`) for transformation
- Removed unnecesary ArrayList initialization

**Stream API Operations Used:**
- `lines()` - Gets stream of lines from BufferedReader
- `filter()` - Filters out empty lines
- `map()` - Transforms each line to Task using method reference
- `collect()` - Collects results into a list

---

### 3. **Storage.java** - `save()` method
**Location:** [src/main/java/zwee/storage/Storage.java](src/main/java/zwee/storage/Storage.java#L60-L73)

**Original Code:**
```java
public void save(TaskList taskList) {
    assert taskList != null : "TaskList should not be null";
    try (FileWriter fw = new FileWriter(file)) {
        for (Task task : taskList.getAll()) {
            fw.write(task.toFileString());
            fw.write(System.lineSeparator());
        }
    } catch (IOException e) {
        throw new ZweeException("Error saving tasks.");
    }
}
```

**Refactored Code:**
```java
public void save(TaskList taskList) {
    assert taskList != null : "TaskList should not be null";
    try (FileWriter fw = new FileWriter(file)) {
        String output = taskList.getAll().stream()
                .map(Task::toFileString)
                .collect(Collectors.joining(System.lineSeparator(), "", System.lineSeparator()));
        fw.write(output);
    } catch (IOException e) {
        throw new ZweeException("Error saving tasks.");
    }
}
```

**Benefits:**
- Uses `Collectors.joining()` instead of manual iteration and concatenation
- Separates concerns - transformation and joining
- More functional approach to building output string
- Single write operation instead of multiple writes

**Stream API Operations Used:**
- `stream()` - Creates stream from task list
- `map()` - Transforms each task to file string using method reference
- `collect(Collectors.joining())` - Joins strings with newline separators

---

### 4. **Ui.java** - `showList()` method
**Location:** [src/main/java/zwee/ui/Ui.java](src/main/java/zwee/ui/Ui.java#L63-L77)

**Original Code:**
```java
public String showList(TaskList tasks) {
    if (tasks.isEmpty()) {
        return "Your task list is empty.";
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < tasks.size(); i++) {
        sb.append((i + 1) + "." + tasks.get(i) + "\n");
    }
    return sb.toString();
}
```

**Refactored Code:**
```java
public String showList(TaskList tasks) {
    if (tasks.isEmpty()) {
        return "Your task list is empty.";
    }
    return IntStream.range(0, tasks.size())
            .mapToObj(i -> (i + 1) + "." + tasks.get(i))
            .reduce((line1, line2) -> line1 + "\n" + line2)
            .orElse("") + "\n";
}
```

**Benefits:**
- Uses `IntStream.range()` instead of traditional for loop
- `mapToObj()` transforms indices to formatted strings
- `reduce()` combines strings with newline separator
- Eliminated StringBuilder mutable state

**Stream API Operations Used:**
- `IntStream.range()` - Creates stream of indices
- `mapToObj()` - Transforms each index to formatted string
- `reduce()` - Combines strings with custom accumulator

---

### 5. **DateTimeUtil.java** - `parseUserDateTime()` and `parseUserDate()` methods
**Location:** [src/main/java/zwee/util/DateTimeUtil.java](src/main/java/zwee/util/DateTimeUtil.java#L28-L95)

**Original `parseUserDateTime()` Code:**
```java
public static LocalDateTime parseUserDateTime(String raw) {
    String trimmed = raw.trim();
    try {
        return LocalDateTime.parse(trimmed, USER_DMY_HHMM);
    } catch (DateTimeParseException ignored) {
        // continue
    }
    LocalDate date = parseUserDate(trimmed);
    return date.atStartOfDay();
}
```

**Refactored `parseUserDateTime()` Code:**
```java
public static LocalDateTime parseUserDateTime(String raw) {
    String trimmed = raw.trim();
    Optional<LocalDateTime> result = Arrays.stream(new DateTimeFormatter[]{USER_DMY_HHMM})
            .map(formatter -> parseWithFormatter(trimmed, formatter, LocalDateTime.class))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .findFirst();
    if (result.isPresent()) {
        return result.get();
    }
    LocalDate date = parseUserDate(trimmed);
    return date.atStartOfDay();
}
```

**Original `parseUserDate()` Code:**
```java
public static LocalDate parseUserDate(String raw) {
    String trimmed = raw.trim();
    try {
        return LocalDate.parse(trimmed, USER_ISO_DATE);
    } catch (DateTimeParseException ignored) {
        // continue
    }
    try {
        return LocalDate.parse(trimmed, USER_DMY);
    } catch (DateTimeParseException ignored) {
        // continue
    }
    throw new ZweeException("Invalid date. Use yyyy-mm-dd (e.g., 2021-01-05) or d/M/yyyy.");
}
```

**Refactored `parseUserDate()` Code:**
```java
public static LocalDate parseUserDate(String raw) {
    String trimmed = raw.trim();
    Optional<LocalDate> result = Arrays.stream(new DateTimeFormatter[]{USER_ISO_DATE, USER_DMY})
            .map(formatter -> tryParseDate(trimmed, formatter))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .findFirst();
    return result.orElseThrow(() -> 
        new ZweeException("Invalid date. Use yyyy-mm-dd (e.g., 2021-01-05) or d/M/yyyy."));
}

private static Optional<LocalDate> tryParseDate(String input, DateTimeFormatter formatter) {
    try {
        return Optional.of(LocalDate.parse(input, formatter));
    } catch (DateTimeParseException ignored) {
        return Optional.empty();
    }
}
```

**Benefits:**
- Eliminates multiple try-catch blocks
- Uses `Optional` for safe null-handling
- `Arrays.stream()` allows iterating over formatters functionally
- Scalable - easy to add more date formats
- `orElseThrow()` provides functional error handling
- Extracted helper method for reusability

**Stream API Operations Used:**
- `Arrays.stream()` - Creates stream from formatter array
- `map()` - Attempts parsing with each formatter
- `filter()` - Filters out failed parsing attempts
- `map(Optional::get)` - Extracts successful results
- `findFirst()` - Stops at first successful parse
- `orElseThrow()` - Provides functional exception handling

---

## Test Results
All unit tests pass successfully after refactoring:
- ✅ DummyTest (2 tests)
- ✅ TaskListTest (6 tests including find() test)  
- ✅ DateTimeUtilTest (3 tests)

Build Status: **SUCCESS**

---

## Key Improvements

### Functional Programming Principles Applied:
1. **Immutability** - Reduced mutable state (ArrayList builders, StringBuilder)
2. **Pure Functions** - Stream operations are side-effect free
3. **Composition** - Methods are chained for clarity
4. **Declarative Style** - Code describes WHAT to do, not HOW to do it

### Code Quality Benefits:
- **Readability** - Intent is clearer with fluent API
- **Maintainability** - Fewer lines of code to maintain
- **Testability** - Functional style is easier to test
- **Conciseness** - Reduced boilerplate code
- **Safety** - Optional handling prevents null pointer exceptions

---

## Compilation Errors Fixed:
- Removed unused `ArrayList` import from Storage.java

---

**Total Methods Refactored: 7**
- TaskList.java: 1 method
- Storage.java: 2 methods  
- Ui.java: 1 method
- DateTimeUtil.java: 2 main methods + 2 helper methods

**All tests passing: YES ✅**
**Code compiled successfully: YES ✅**
